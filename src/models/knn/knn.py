import osimport sysMODELS = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))SRC = os.path.abspath(os.path.join(MODELS, os.pardir))sys.path.append(SRC)import utilsimport numpy as npimport pandas as pdfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.model_selection import cross_validatefrom sklearn.model_selection import GridSearchCVfrom sklearn.preprocessing import Normalizerfrom sklearn.preprocessing import RobustScalerfrom sklearn.preprocessing import OneHotEncoder"""Este script lo utilizo para ver también el accuracy en train para los mejores modelosencontrados en los otros scripts. Una vez vistos(y que no tengan overfitting), realizola submission con el código comentado más abajo"""train_raw = utils.load_train_KnnImp()#train_raw = utils.load_train()train_raw = utils.merge_numerical(train_raw) #PARA MERGEAR LAS COLUMNAS VISTAS EN EDAtrain_X = utils.one_hot_encode(df = train_raw.drop(["Transported", "PassengerId"], axis = 1))NormScal = Normalizer()df_array = NormScal.fit_transform(train_X)train_X_NormScal = pd.DataFrame(df_array,columns=train_X.columns)RobScal = RobustScaler()df_array = RobScal.fit_transform(train_X)train_X_RobScal = pd.DataFrame(df_array,columns=train_X.columns)train_y = train_raw.Transportedscore_cv = cross_validate(estimator = KNeighborsClassifier(58,metric = 'correlation'),                              X = train_X_RobScal, y = train_y, cv = 10, n_jobs = -1,return_train_score=True)print("Train score: %.4f %.4f"%(np.mean(score_cv["train_score"]),np.std(score_cv["train_score"])))print("Test score: %.4f %.4f"%(np.mean(score_cv["test_score"]),np.std(score_cv["test_score"])))print(score_cv["test_score"])score_cv = cross_validate(estimator = KNeighborsClassifier(n_neighbors=53,p=2),                              X = train_X_RobScal, y = train_y, cv = 10, n_jobs = -1,return_train_score=True)print("Train score: %.4f %.4f"%(np.mean(score_cv["train_score"]),np.std(score_cv["train_score"])))print("Test_score: %.4f %.4f"%(np.mean(score_cv["test_score"]),np.std(score_cv["test_score"])))print(score_cv["test_score"])"""weights = ["uniform", "distance"]start = time.time()knn = KNeighborsClassifier()k_range = list(range(1,60))pgrid = {'n_neighbors':k_range,'p':[1,2]}grid = GridSearchCV(knn, pgrid, scoring='accuracy', n_jobs = -1, cv =10, return_train_score=True)grid_search = grid.fit(train_X_RobScal,train_y)print(grid_search.best_params_)time_taken = time.time() - startprint('Tiempo que tarda gridsearch:',time_taken)#----------------------------BASTANTE MÁS RÁPIDO ASÍ:(?)-------------------------colnames = train_X.columnsoptim_score = 0.for (low,high) in zip(np.arange(20,40,1),np.arange(80,60,-1)):    for p_ in [1,2]:        for i in range(5,50):            RobScal = RobustScaler(quantile_range=(low,high))            df_array = RobScal.fit_transform(train_X)            train_X_scaled = pd.DataFrame(df_array,columns=colnames)                        score_cv = cross_validate(estimator = KNeighborsClassifier(n_neighbors=i, p = p_),                                      X = train_X_scaled, y = train_y, cv = 10, n_jobs = -1)            print(round(np.mean(score_cv["test_score"]),5))            score_test = np.mean(score_cv["test_score"])            if score_test > optim_score:                optim_score = score_test                k_optim = i                p_optim = p_                low_optim = low                high_optim = high#                w_optim = wprint('Mejor resultado:',optim_score,'\n Para k=',k_optim,' y p= ',p_optim)"""#Predicciones en el testtest_raw = utils.load_test_KnnImp()test_raw = utils.merge_numerical(test_raw)test = utils.one_hot_encode(df = test_raw.drop(["PassengerId"], axis = 1))test_scaled_array = RobScal.transform(test)test_scaled = pd.DataFrame(test_scaled_array,columns=test.columns)knn = KNeighborsClassifier(n_neighbors = 58, metric = 'correlation').fit(train_X_RobScal,train_y)pred_labels = knn.predict(X = test_scaled)predicted_labels = utils.encode_labels(pred_labels)utils.generate_submission(labels = predicted_labels, method = "knn", notes = "RobScal_k_58_correlation_merged_knnImp")